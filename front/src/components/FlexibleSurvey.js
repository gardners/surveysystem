import React from 'react';
import * as Survey from "survey-react";
import { Configuration } from '../conf/config';
import LoadingSpinner from './LoadingSpinner';
import geolocationQuestion from '../customQuestions/geolocationQuestion'

import api from '../api';
import Log from '../Log';
import LocalStorage from '../storage/LocalStorage';

import Dev from './Dev';
import MessageTray from './MessageTray';

// Represents the Flexible Survey
class FlexibleSurvey extends React.Component {

    //The ID of the survey to load from the server
    //the ID is retrieved from the url, that looks like : /survey/:id
    surveyID = this.props.match.params.id
    //The ID of the session, as identified by the back end
    //the session id generated by the server, and used by the front and back during the whole survey process
    sessionID = null
    //contains an array listing all question objects, by this way : [questionId => {question}, etc...]
    questions = []
    //contains an array listing all added pages(and the question it contains) objects to the survey, by this way : [pageId => {page}, etc...]
    //a page must at least have 1 question, and as many as wanted
    //a new page is created each time the back send the next question(s) to answer
    pages = []
    //allows to know the number of pages currently in the survey. It is also used to set the pageId of a page
    //the stepId is incremented by 1 each time a new set of questions is added to the survey
    stepID = 0
    // contains the question ID that are asked currently to the user
    //used for logs
    currentQuestionsBeingAnswered = []
    //when there are no more questions to ask, set to true
    surveyCompleted = false




    // Constructor, needed in every case in React
    // survey is the react component from surveyjs. It is the backbone of this front app
    // loading is used to know if an ajax request is being made. If so, a loading spinner is shown while loading == true
    constructor(props) {
        super(props);
        this.state = {
            survey : new Survey.Model(),
            loading : true,
            messages : [],
        };
    }


    // configure SuveyJs
    // put here the configuration of the global survey object, such as the theme, etc.
    initSurveyJs(){
        Survey.StylesManager.applyTheme(Configuration.surveyTheme)
        Survey.CustomWidgetCollection.Instance.addCustomWidget(geolocationQuestion, "customtype")
        this.addCustomProperties()
    }

    // initializes Survey
    // such as event listeners, etc.
    initSurvey(survey){
        //this.configureNextAndPreviousButtons(survey)
        this.configureNextAndPreviousButtons()
    }

    //adds the listeners to next and previous buttons
    //it also configures the diplayed text on the completeText button
    configureNextAndPreviousButtons(survey = null){
        let tmpSurvey = (survey) ? survey : this.state.survey
        tmpSurvey.completeText = "Next - fake"

        //eventlistener when user presses prev
        tmpSurvey.onCurrentPageChanged.add(function(sender, options){
            if(!options.oldCurrentPage || !options.newCurrentPage) return; //showing first page
            if(options.oldCurrentPage.visibleIndex > options.newCurrentPage.visibleIndex){
                Log.log('button PREV pressed')
                this.goBackToPreviousStep();
            }
        }.bind(this));

        //eventlistener when user presses next
        //it is not really the next button, but complete button, with a display text set at 'Next', since the current displayed page is always the last one.
        tmpSurvey.onCompleting.add(function(sender, options){
            if (this.surveyCompleted){
                options.allowComplete = true
            } else {
                options.allowComplete = false
                this.onNextButtonPressed(sender, options)
            }
        }.bind(this));

        tmpSurvey.onComplete.add(function(){
            // clear local cache after completion
            this.removeStateFromStore();
        }.bind(this));

        this.setState({
            survey : tmpSurvey
        });
    }

    //you may want, while creating a new survey, add some custom properties in the question, such as their ID.
    // to declare these new properties, go to the config file. this function will automatically import them when the survey is built
    addCustomProperties(){
        for (let id in Configuration.customProperties){
            let customProperty = Configuration.customProperties[id]
            Survey.JsonObject.metaData.addProperty(customProperty.basetype, { name: customProperty.name, type: customProperty.type });
        }

    }

    //get a question saved in the component's properties by its id
    getQuestionById(id){
        const tmpQuestions = this.questions;
        if (!(id in tmpQuestions)){
            Log.error("There is no questions defined by the id "+id);
            return null;
        }
        return tmpQuestions[id];
    }

    //get a page saved in the component's properties by its id
    getPageById(id){
        let tmpPages = this.pages
        if (!(id in tmpPages)){
            Log.error("There is no page defined by the id "+id);
            return null;
        }
        return tmpPages[id];
    }

    isQuestionAlreadyInSurvey(questionId){
        for (let pageID in this.pages){
            let page = this.pages[pageID]
            for (let questionID in page.questions){
                let questionInSurvey = page.questions[questionID]
                if (questionId === questionInSurvey.id){
                    return true
                }
            }
        }
        return false
    }

    //accepts a list of question IDs, and add the corresponding questions in a new page, at the end of the survey
    setNextQuestionOfSurvey(questionIds){
        let tmpSurvey = this.state.survey
        let tmpStepID = this.stepID
        let newPage = tmpSurvey.addNewPage(tmpStepID);
        let nbOfQuestionsAdded = 0
        for (let id in questionIds){
            let questionId = questionIds[id]
            Log.log("adding the next question (id="+questionId+") at the end of survey...");
            const questionToAdd = this.getQuestionById(questionId);
            if (!questionToAdd){
                Log.error("failed to get the question with id "+questionId+" !");
                return null;
            }
            if(!this.isQuestionAlreadyInSurvey(questionId)){
                newPage.addQuestion(questionToAdd);
                Log.log("question (id="+questionId+") added at the end of survey...");
                nbOfQuestionsAdded++
            }
            else{
                Log.error("question (id="+questionId+") already exists in the survey, it is not added again");
            }
        }
        let res = null
        if (nbOfQuestionsAdded > 0){
             res = this.saveNewPage(tmpStepID, newPage);
        } else {
            Log.log("no pages are added at the end of the survey, since no questions were added" )
            return null
        }

        if (!res){
            Log.error("Setting of the next question failed : an already existing id (id="+tmpStepID+") was used as argument ");
            return null;
        }
        this.currentQuestionsBeingAnswered[this.stepID]  = questionIds
        this.stepID = tmpStepID + 1;
        this.setState({
            survey : tmpSurvey
        });
        return true
    }


    //TODO : comment it later
    async deleteAnswersFromServer(){
        Log.log('==============================================')
        Log.log('deleting answers from server...')
        let currentQuestions = this.getCurrentQuestions()
        for (let id in currentQuestions) {
            let questionToDelete = currentQuestions[id]
            let resolved = await api.deleteAnswer(this.sessionID, questionToDelete.id)
            if(resolved.error) {
                Log.error("An error happened while asking to create a new session ! log :")
                Log.log(resolved.error.response.data)
            }
        }
    }

    //TODO: not used yet in the new version, document it when it's done
    goBackToPreviousStep(){
        Log.log('Going back to previous step...');
        this.setState({ loading: true }, async () => {
            await this.deleteAnswersFromServer()
            this.deleteMostRecentPageOfSurvey()
            this.pages = this.pages.slice(0, -1);
            this.stepID = this.stepID -1;
            Log.log('Done going back to the previous step...');
            this.setState({
                loading: false
            }, () => {this.saveStateToStore(this.state.survey)})
        });
    }


    //TODO: put completeText in a new function
    deleteMostRecentPageOfSurvey(){
        Log.log("page to delete : ")
        Log.log(this.getCurrentPage())
        let pageToDelete = this.getCurrentPage()
        let tmpSurvey = this.state.survey
        tmpSurvey.completeText = "Next - Fake"
        this.surveyCompleted = false
        tmpSurvey.removePage(pageToDelete)
        this.setState({
            survey: tmpSurvey
        })
    }


    //allows to get the root element of the json received by the server
    //when receiving the survey from the server, they must be encapsulated in a root element, like data (by default with a nodejs server) or questions (or whatever you want)
    getRootFromJson(json){

        Log.log('getting the root element from the json...')
        let root
        let cpt = 0
        for (let key in json){
            root = key
            cpt++
        }
        if(cpt > 1){
            Log.error("ERROR : the json sent must be encapsulated in a UNIQUE root element(that contains all the data)")
            return null
        }
        if(!root){
            Log.error("ERROR : the json received from the server is empty !")
            return null
        }
        return root
    }

    //TODO: not used yet in the new version, document it when it's done
    finishSurvey(){
        let tmpSurvey = this.state.survey
        tmpSurvey.completeText = "Complete"
        this.surveyCompleted = true
        this.setState({
            survey : tmpSurvey
        })
    }

    //there are no more questions to display when no more questions are sent from the server (i.e. when the array questions is empty)
    isThereAnotherQuestion(questionIds){
        if (Array.isArray(questionIds) && questionIds.length === 0){
            return false
        }
        return true
    }


    //TODO : partly done for the moment, wait until its finished before commenting
    processQuestionReceived(questionInJson){
        Log.log("A question was received from the server")
        Log.log("Data received by the server :")
        Log.log(questionInJson)

        let questionIdsToAdd = this.deserialize(questionInJson)
        if (this.isThereAnotherQuestion(questionIdsToAdd)) {
            Log.log("These questions will be added at the end of the survey :")
            Log.log(questionIdsToAdd)
            this.setNextQuestionOfSurvey(questionIdsToAdd)
            let tmpSurvey = this.state.survey
            tmpSurvey.nextPage()
            this.setState({
                survey : tmpSurvey
            })
            this.saveStateToStore(tmpSurvey)
        } else{
            Log.log("There is no more questions to display, the survey can be completed ")
            this.finishSurvey()
        }
    }

    //issue #4 : when an unknown property to surveyjs is found, it is added to it to not make the survey crash, and log an error to the user
    checkThatEveryPropertyExist(questionJson){
        Log.log('checking that all the properties exist...')
        const questionObject = Survey.JsonObject.metaData.createClass(questionJson.type);
        if(!questionObject){
            Log.error("failed to create the question object from the json");
            return null;
        }
        for (let property in questionJson){
            Log.log('tested property : ' + property )
            if (property in questionObject || property === 'type'){//I guess that the type is not needed in the object at this stage
                Log.log('OK')
            } else{
                Log.log('NOK')
                Survey.JsonObject.metaData.addProperty('questionbase', { name: property, type: 'string' });
                Log.error('The property ' + property + ' was added in the survey. But it is a bad practice, you must declare custom properties in the config.js file !')
            }
        }
    }

    // transforms the json list of questions into objects, used later to manipulate the survey.
    // at this point, the questions are not added in the survey, they just "exist" as objects
    // warn : each question MUST have a unique id property
    deserialize(json){
        Log.log("starting the deserialization...");

        let questionIds = [];
        const root = this.getRootFromJson(json)
        if (!root){
            Log.error("ERROR : the json data received by the server is not adequate")
            return null
        }
        const questions = json[root];
        let cpt =0;

        for ( let key in questions){
            Log.log("deserializing question number " + cpt);
            let tmpJsonQuestion = questions[key];
            let questionId = this.getJsonAttribute("id", tmpJsonQuestion)
            questionIds.push(questionId)
            //issue #4 : check that all the properties are recognised by surveyjs. If not, adds them and log an error message
            this.checkThatEveryPropertyExist(tmpJsonQuestion)
            let newQuestion = this.createQuestionObjectFromJson(tmpJsonQuestion);
            this.saveNewQuestion(questionId, newQuestion);
            cpt++;
        }

        Log.log("deserialization complete of the " + cpt + " incoming questions")
        return(questionIds)
    }


    // allows to get attributes in question objects, like the id (a question shouldn't have an id attribute in surveyjs)
    // can be also used to get any attribute of any object
    // returns the attribute
    // warn : the attribute should be a direct attribute of the object (doesn't work with attributes of children)
    getJsonAttribute(attribute, jsonObject){
        Log.log('jb', attribute, jsonObject);
        Log.log("getting attribute "+ attribute + "...");
        if (!jsonObject.hasOwnProperty(attribute)){
            Log.error("the attribute " + attribute + " doesn't exist ! You MUST give an id attribute to each question in the JSON");
            return null;
        }
        Log.log("attribute " + attribute + " get");
        return jsonObject[attribute];

    }

    //saves a new question into the Component properties
    // at this stage, the question is bound with an id, and only "exists" : it is not part of the survey yet
    saveNewQuestion(id, question){
        Log.log("saving question with id="+id+"...");
        let tmpQuestions = this.questions;
        tmpQuestions[id] = question;
        this.questions = tmpQuestions;
        Log.log("question with id="+id+" saved");
    }


    //saves a new page into the array of pages
    // its ID is the current stepID value
    saveNewPage(id, page){
        Log.log("saving page with id="+id+"...");
        let tmpPages = this.pages;
        if (id in tmpPages){
            Log.error("You want to add a page with the same id(id="+id+") as an already existing page !");
            return null;
        }

        tmpPages[id] = page;
        this.pages = tmpPages;
        Log.log("page with id="+id+" saved");
        return true;
    }

    //converts a json formatted question into a Question class of surveyjs
    createQuestionObjectFromJson(questionJson) {
        if(!questionJson.type){
            Log.error("no type found in question");
            return null;
        }
        const question = Survey.JsonObject.metaData.createClass(questionJson.type);
        if(!question){
            Log.error("failed to create the question object from the json");
            return null;
        }
        Survey.JsonObject.prototype.toObject(questionJson, question);
        return question;
    }


    //converts a json formatted page into  a PageModel class of surveyjs
    createPageObjectFromJson(survey, step, jsonData, questions) {
        const classInstance = survey.addNewPage(step);

        if(!classInstance ){
            Log.error("failed to create the page object from the json");
            return null;
        }

        // add question instances to page
        questions.forEach((questionJson) => {
            // build question instance
            const q = this.createQuestionObjectFromJson(questionJson);
            classInstance.addQuestion(q);
        });

        return classInstance;
    }

    //checks that the user answered the question before submitting it (i.e its not an empty question)
    isAnswerEmpty(answer){
        if (!answer){
            return true
        }
        return false
    }

    //TODO : comment that
    getCurrentPage(){

        return this.pages[this.stepID-1]
    }

    // TODO : comment that
    getCurrentQuestions(){
        return this.pages[this.stepID-1].questions
    }

    //returns the questions Ids and their answers
    // returned format : [{id : "ID of the question', answer : "user's answer"}, ... ]
    getAnswersOfCurrentPage(){
        let answers = []
        let cpt =0
        Log.log('Getting answers from the current page...')
        const questionsList = this.getCurrentQuestions()
        for (let id in questionsList){
            let question = questionsList[id]
            if (!this.isAnswerEmpty(question.value)){
                answers[cpt] = {
                    id : question.id,
                    answer : question.value,
                    question : question
                }
                cpt++
            } else {
                Log.error('Please answer the question')
                return null
            }
        }
        return answers
    }

    //TODO : this function must be completed and improved
    defineAnswerType(answer){
        if(!answer){
            Log.error('The answer type cannot be determined since the answer is null or undefined !')
            return null
        }
        let questionType = null
        let question = answer.question
        if (question.getType() === 'geolocation'){
            questionType = 'geolocation'
        }
        else if (question.inputType === 'number'){
            questionType = 'value'
        }
        else{
            questionType = 'text'
        }
        Log.log('The answer type of question #' + answer.id + ' is : ' + questionType)
        return questionType
    }


    //TODO : not finished yet properly, wait until commenting
    //TODO : special case for lat lon not implemented
    // the answer has these fields :
    // DESERIALISE_STRING(a->uid);
    // DESERIALISE_STRING(a->text);
    // DESERIALISE_LONGLONG(a->value);
    // DESERIALISE_LONGLONG(a->lat);
    // DESERIALISE_LONGLONG(a->lon);
    // DESERIALISE_LONGLONG(a->time_begin);
    // DESERIALISE_LONGLONG(a->time_end);
    // DESERIALISE_INT(a->time_zone_delta);
    // DESERIALISE_INT(a->dst_delta);
    serializeToCSV(lastAnswers){
        Log.log("Serializing" + lastAnswers.length + " answers to CSV...")
        let lastAnswersCSV = []
        for(let id in lastAnswers){
            let cptForLogs = parseInt(id, 10) + 1
            let lastAnswer = lastAnswers[id]
            let lastAnswerCSV = ""
            let answerFieldsCSV = {
                uid : lastAnswer.id,
                text : '0',
                value : '0',
                lat : '0',
                lon : '0',
                time_begin : '0',
                time_end : '0',
                time_zone_delta : '0',
                dst_delta : '0'
            }
            let questionType = this.defineAnswerType(lastAnswer)
            answerFieldsCSV[questionType] = lastAnswer.answer //at this moment, the answerFieldsCSV contains the questionID, and the answer of the question in the good field
            for (let fieldID in answerFieldsCSV){
                if(fieldID === "uid"){
                    lastAnswerCSV = lastAnswerCSV.concat(answerFieldsCSV[fieldID])
                }
                else {
                    lastAnswerCSV = lastAnswerCSV.concat(':',answerFieldsCSV[fieldID])
                }

            }
            Log.log("Serialization of answer " + cptForLogs + "/" + lastAnswers.length + " done ! output = " + lastAnswerCSV)
            lastAnswersCSV[id] = lastAnswerCSV
        }
        return lastAnswersCSV
    }


    //TODO : function not finished yet, comment it later
    //function called when the user press Next button
      onNextButtonPressed(result, options){
        this.setState({ loading: true });

        Log.log("NEXT button pressed")
        // fetch input value of current question
        const lastAnswers = this.getAnswersOfCurrentPage()
        Log.log(lastAnswers)
        if(!lastAnswers){
            this.setState({ loading: false });
            return;
        }

        //format current answer to csv
        const lastAnswersCSV = this.serializeToCSV(lastAnswers)
        Log.log("This data will be sent to the server :")
        Log.log(lastAnswersCSV)

        // send current answer
        //loading while the questions are sent and the next question is not displayed

        Promise.all(
            Object.keys(lastAnswersCSV).map(id => api.updateAnswer(this.sessionID, lastAnswersCSV[id]))
        )
        .then(responses => responses.pop()) // last
        .then(nextQuestion => this.processQuestionReceived(nextQuestion))
        .then(this.setState({ loading: false }));
    }


    // //sends a request to the server to get the next set of questions to display
    askNextQuestion(){
        api.nextQuestion(this.sessionID)
        .then(nextQuestion => this.processQuestionReceived(nextQuestion))
        .then(() => this.setState({ loading: false }))
    }

    /**
     * Create a new survey session
     * @see componentDidMount
     */
    initNewSession(){
        Log.log("version 6")
        this.setState({ loading: true });

        this.initSurveyJs();

        api.createNewSession(this.surveyID)
        .then((sessID) => {
             this.sessionID = sessID;
             this.initSurvey();
             return sessID;
        })
        .then(sessID => this.askNextQuestion(sessID))
        .catch((err) => { throw err; });
    }

    /**
     * Restore a cached survey session
     * @param {object} cachedSess session data from localCache
     * @see componentDidMount
     */
    initStoredSession(cachedSess){
        Log.log("load cached session, version 6");
        this.setState({ loading: true });
        this.initSurveyJs();
        this.mergeStoredState(cachedSess);
        this.initSurvey();
        this.setState({ loading: false });
    }

    // TODO separate out

    /**
     * Stores the current suvery state in localStorage
     * @returns {void}
     */
    saveStateToStore(survey) {
        const res = {
            currentPageNo: survey.currentPageNo,
            data: survey.data,
            surveyID : this.surveyID,
            sessionID : this.sessionID,
            pages : this.pages,
            stepID : this.stepID,
            currentQuestionsBeingAnswered: this.currentQuestionsBeingAnswered,
            surveyCompleted : this.surveyCompleted
        };
        localStorage.setItem('sessionstate', JSON.stringify(res));
    }

    /**
     * Stores the current suvery state in localStorage
     * @returns {object|null}
     */
    getStateFromStore() {
        return LocalStorage.get('sessionstate');
    }

    /**
     * Stores the current suvery state in localStorage
     * @returns {void}
     */
    removeStateFromStore() {
        return LocalStorage.delete('sessionstate');
    }


    /**
     * validates the state in localstorage against the current (initialized) instance
     * ? stored suveyID === current surveyID
     * ? has seeionId
     * @returns {boolean}
     */
    validateStoredState() {
        const stored = this.getStateFromStore();
        if(!stored) {
            return false;
        }

        const { surveyID, sessionID } = stored;
        if(surveyID === this.surveyID && sessionID) {
            return true;
        }

        return false;
    }

    // in localstorage, pages are stored as objects, and not as PageModels
    // this function create a new page model, add all the questions and their answers to it.
    // this functions creates as many new page models as there are pages stored in the localstorage
    restorePages(pages, data){
        let newPages=[]
        for (let id in pages){
            let page = pages[id]
            let newPage = new Survey.PageModel()
            for (let questionID in page.elements){
                let questionJson = page.elements[questionID]
                let questionObject = this.createQuestionObjectFromJson(questionJson)
                newPage.addQuestion(questionObject)
                questionObject.value = data[questionObject.name]
                newPages[id] = newPage
            }
        }
        return newPages
    }

    // this function adds to the survey the restored pages just before
    restoreSurvey(survey){
        for (let id in this.pages){
            let page = this.pages[id]
            survey.addPage(page);
        }
        return survey
    }
    /**
     * validates the state in localstorage against the current (initialized) instance
     * ? stored suveyID === current surveyID
     * ? has seeionId
     * @returns {Survey.Model}
     */
    mergeStoredState(storedState) {
        let tmpSurvey = this.state.survey

        let res = storedState
        this.stepID = res.stepID
        this.surveyID = res.surveyID
        this.pages = res.pages
        this.sessionID = res.sessionID
        this.surveyCompleted = res.surveyCompleted
        this.currentQuestionsBeingAnswered = res.currentQuestionsBeingAnswered

        this.pages = this.restorePages(res.pages, res.data)
        tmpSurvey = this.restoreSurvey(tmpSurvey)

        //Set the loaded data into the survey.
        if (res.currentPageNo) {
            tmpSurvey.currentPageNo = res.currentPageNo;
        }

        if (res.data) {
            tmpSurvey.data = res.data;
        }

        this.setState({
            survey : tmpSurvey
        })
    }

    //this function is fired when the page is loaded
    componentDidMount(){

        Log.subscribe('FlexibleSurvey', messages => this.setState({ messages }));

        if(this.validateStoredState()) {
            const sess =  this.getStateFromStore();
            this.initStoredSession(sess);
            return;
        }

        this.initNewSession();
    }



    // if an ajax request is loading, a spinner is shown. If a question is available, the survey is shown
    render(){
        return(
            <section>
                <pre>step: { this.stepID }, session: { this.sessionID }, env: { process.env.NODE_ENV }</pre>


                <div className="jumbotron jumbotron-fluid">
                    <div className="container">
                        {this.state.loading ? <LoadingSpinner /> : <Survey.Survey model={this.state.survey}/>}
                    </div>
                </div>

                <Dev label="localState" data={ this.getStateFromStore() } open={ false }/>
                <MessageTray entries={ this.state.messages } />
            </section>
        );
    }
}

export default FlexibleSurvey;
